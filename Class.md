## 构造方法
```java
// 权限修饰符  类型一致的方法名([参数列表])[异常]{}
public Class Person {
   public String name;

   public Person() {}
   // 构造方法重载
   public Person(String name){
      this.name = name;
   }
}

// 通过new调用
Person p = new Person();
```
每个类都有构造方法，若在自己定义的类中没有定义，系统会默认提供一个无参数的构造方法。

若在自己的类中定义了构造方法，则默认无参的构造方法即被覆盖

构造方法
## 类属性
```java
/*权限修饰符 [特征修饰符] 数据类型 属性名字[ = 值]*/
public String name;
```
![](images/7.png)
## 类方法
```java
// 权限修饰符 [特征修饰符] 返回值类型 方法名字([参数列表]) [抛出异常][{
//    [方法体]
// }]
```
类方法存储在**堆内存**的对象空间内。

类方法是在**栈空间**内执行的

形参与实参

形参可以理解为是方法执行时的临时变量空间(x)

实参可以理解为是方法调用时传递进去的参数(a)

方法调用时会将实参的内容传递给形参
1. 如果内容是基本类型，传递 - 值    形参改变，实参未变
2. 如果内容是引用类型：传递 - 引用  形参改变，实参也跟着改变
![](images/8.png)
![](images/9.png)
## 方法重载 - overload
1. 一个类中的一组方法，方法名相同，参数列表不同，构成了方法重载
2. 参数列表的不同：
   1. 参数的个数
   2. 参数的类型
   3. 参数的顺序
3. 动态参数列表
   ```java
   public void test(int ...x); // √ 类型固定，个数不固定[0...n], 本质上是一个数组int[] x;但不能与int[] x构成重载
   public void test(int a, int ...x); // √
   public void test(int[] x); // ×；与第1个冲突
   ```
   动态参数列表(```int ..x```)不能与```int[] x```不能构成重载。这两个本质上都是数组。

   区别：动态参数列表的方法，可以不传参数(相当于空数组)；数组的方法必须传递参数
## 程序块
1. 作用：跟普通方法一样
2. 写法：可以认为程序块是一个没有修饰符、没有参数、没有返回值、没有名字的特殊方法
   ```java
   public class Person {
      public String name;
      public constructor(String name) {
         this.name = name;
      }

      public String getName() {return this.name;}

      // 程序块
      {
         System.out.println("这是Person类的一个程序块");
      }
   }
   ```
3. 用法：程序块也需要调用才能执行（我们自己调用不到-没有名字）
   每一次我们调用构造方法之前，系统会帮助我们自动的调用一次程序块，让他执行一遍。

4. 类中可以有多个程序块
5. 使用场景：需要在创建对象之前（constructor）执行
## this关键字
1. this是一个关键字，代替的是某一个对象（当前调用属性或方法时的那个对象）
2. this可以调用属性、方法及**构造函数**
3. 可以在一个构造方法内通过```this()```调用另一个构造方法（省略了构造方法的名字）。必须在另一个构造方法内调用，必须在程序的第一行。
4. 构造方法、一般方法是有顺序的，认为构造方庄早于一般方法。
5. 不能在一般方法内调用构造方法
6. 构造方法可以重载
## 类与类之间的关系
### A is-a B 泛化(继承、实现)
#### 继承
1. 子类通过关键字``` extends```继承父类
2. 子类的对象可以调用父类中(```public/protect```)属性和方法。
   1. 构造方法严格意义来讲，不算子类继承过来的，只是单纯的在子类调用构造方法时默认调用父类的构造方法
   2. 程序块严格意义上来说，不算子类继承过来（子类自己调用不到-没名字）。程序块子类不能直接调用，子类执行构造方法之前默认调用了父类的构造方法，父类构造方法之前自动执行父类的块。
3. 子类可以添加自己的属性和方法
4. 子类从父类中继承过来的方法不能满足子类需要时，可以在子类中重写（覆盖）父类的方法。

   ||方法重写(override)|方法重载(overload)
   --|--|:--:|
   |类| 有继承关系的类,子类重写父类的方法 | 一个类中的一组方法 |
   权限 | 子类可以大于等于父类 | 没有要求 |
   final | 父类方法是final，子类不能重写|没有要求|
   static | 父类方法是static，子类不存在重写|没有要求|
   abstract | 父类是abstract 子类必须重写，否则子类也得是抽象类|没有要求|
   返回值|子类的返回值可以小于等于父类|没有要求|
   名字|子类与父类必须一致|一个类中的好多方法名必须一致
   参数|子类与父类必须一致|每一个方法的参数必须不一致(类型、个数、顺序)
   运行时异常|如果父类方法抛出运行时异常，子类可以不予理会| 没有要求
   编译异常|如果父类方法抛出编译时异常，子类抛出异常的个数少于等于父类，子类抛出异常的类型小于等于父类 | 没有要求
   方法体|

5. 每一个类都有继承类，如果不写```extends```关键字，则默认继承```Object```，如果写了```extends```则继承后面的那个类。
   
   可以理解为```Object```类是任何一个引用类型的父类（直接或间接的继承```Object```）。```Object```类没有父类。

   |Object中的方法|说明
   --|:--|
   |hashCode()|将对象在内存中的地址经过计算得到一个int整数|
   |equals()|用来比较两个对象内容,Object默认的比较效果是==；基本类型-比较值；引用类型-比较地址。equals是Object类中继承过来的方法，默认效果是比较地址。如果想要改变其规则，可以进行方法重写。
   |toString()| 打印输出时将一个对象变成字符串|
   |getClass()|获取对象对应类的类映射(反射)
   |wait()|线程进入挂起等待状态
   |notify()|线程唤醒
   |notifyAll()|唤醒所有
   |finalize()|protected，在对象被GC回收的时候，默认调用执行的方法。
   |clone()|protected 为了克隆对象
6. 在Java中是单继承-每一个类只能有一个继承类（在```extends```关键字只能写一个类）。

   可能通过传递的方式实现多继承的效果

   后续还会有多继承(**实现**)
7. 继承在内存中的存储形式
   ![](images/10.png)
8. 关于this和super
   
   this和super代替的都是对象

   this指的是当前**执行方法时**的那个对象（注意区分当前类的对象）

   super指的是当前执行方法时的对象的父类对象
   
   都能调用一般属性和一般方法

   可以放置在类成员的任意位置（属性、方法、构造、块）

   可以调用构造方法

   this和super在构造方法中调用另一个类的构造方法不能同时出现在第一行。

### A has-a B 包含(组合、聚合、关联)

### A use-a B 依赖(依赖)(need-a)
